<!doctype html><html lang=zh><head><meta name=viewport content="width=device-width,initial-scale=1"><title>还是偶尔想要伟大</title><meta charset=utf-8><meta name=description content="Ladder@根据php-fpm-entrypoint学习如何设计容器的入口文件"><meta name=author content="易初"><link rel=canonical href=https://y7ut.github.io/zh/blog/zh/learn-design-image-entrypoint/><meta property="og:title" content="如何设计容器的 Entrypoint 🚪"><meta property="og:description" content="根据php-fpm-entrypoint学习如何设计容器的入口文件"><meta property="og:type" content="article"><meta property="og:url" content="https://y7ut.github.io/zh/blog/zh/learn-design-image-entrypoint/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-08-29T12:14:34+08:00"><meta property="article:modified_time" content="2022-08-29T12:14:34+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="如何设计容器的 Entrypoint 🚪"><meta name=twitter:description content="根据php-fpm-entrypoint学习如何设计容器的入口文件"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":4,"name":"如何设计容器的 Entrypoint 🚪","item":"https://y7ut.github.io/zh/blog/zh/learn-design-image-entrypoint/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"如何设计容器的 Entrypoint 🚪","name":"如何设计容器的 Entrypoint 🚪","description":"根据php-fpm-entrypoint学习如何设计容器的入口文件","keywords":["bash","docker"],"articleBody":"在整理php-fpm官方镜像构架方法的时候，注意到了一个入口文件 docker-php-entrypoint， 和 DockerFile 的写法\nENTRYPOINT [\"docker-php-entrypoint\"] CMD [\"php-fpm\"] 为什么要要这样设计呢，入口文件的好处是什么的呢？\n🤔️我们来研究一下，先看一下这个 docker-php-entrypoint 文件\n#!/bin/sh set -e # first arg is `-f` or `--some-option` if [ \"${1#-}\" != \"$1\" ]; then set -- php-fpm \"$@\" fi exec \"$@\" bash脚本中的set指令 从上到下看，先看一下文件开头的set -e\n最常用的两个参数就是 -e 与 -x ，一般写在 bash 脚本的代码逻辑之前，这两个组合在一起用，可以在 Debug 的时候替你节省许多时间 。\nset -x 会在执行每一行 shell时，把执行的内容输出来。它可以让你看到当前执行的情况，里面涉及的变量也会被替换成实际的值。 set -v 会在执行每一行 shell时，把执行的内容输出来, 但里面涉及的变量不会被替换。 set -e 会在执行出错时结束程序，就像其他语言中的“抛出异常”一样。 set -u 会在执行 shell时, 如果遇到不存在的变量会忽略掉这个问题 例如\n#!/bin/bash # 打印每一行语句的执行情况，执行错误时，则立即退出脚本 # set [-可选参数] [-o 选项] set -ex 当然还有一些参数需要携带option， 也是常用的设置，例如:\nset -o pipefail 对于用管道符|连接的命令，如果最后一个命令执行成功，那么这整个命令则会被认为执行成功，大多数情况下是不符合我们需求的。所以设置了这个选项之后，某个子命令出错的时候直接退出。 所以我们在设计一些脚本的时候，可以调加这样的配置让脚本更健壮。\n#!/bin/bash set -euxo pipefail ... 修改脚本的输入参数 一般来说，在shell脚本中 $1,$2,$3,$@ , 用来代表输入的参数\n$! ：Shell最后运行的后台 Process 的 PID (后台运行的最后一个进程的进程 ID 号)。 $# ：添加到shell当中参数的个数. $$ ：Shell 本身的 PID (ProcessID，即脚本运行的当前进程 ID 号)。 $0 ：脚本本身的文件名. $1 ：传到 Shell 当中的第一个参数。 $2 ：传到 Shell 当中的第二个参数。 $* ：所有参数列表。如 $* 用\" “括起来的情况、以 $1 $2 … $n 的形式输出所有参数，此选项参数可超过9个；若不加” “，那么 $* 与 $@ 的输出结果相同 $@ ：所有参数列表。如 $@ 用” “括起来的情况、以 $1 、$2、 … $n 的形式输出所有参数。 所以php-fpm-entrypoint的这个 ${1#-} 其实则是指的是用来，获取第一个参数，并去除掉左面的第一个 -。\neg.1 ${1#*-} # 去除掉左面第一个-和左面所有字符 eg.2 ${1#-*} # 去除掉左面第一个-和右面所有字符 eg.3 ${1##-*} # 去除掉左面数最后一个（右面第一个）- 和右面所有字符 eg.4 ${1%-*} # 去除掉右面第一个- 和右面所有字符 eg.5 ${1%%*-} # 去除掉右面数最后一个一个（左面第一个）- 和左面所有字符 所以 ${1#-} 表达的，如果输入的第一个参数不是去掉了左侧第一个的-不等于参数本身\n可以理解为 如果输入的是一个 -v 或者 —int 类似参数的话，就会进入if的代码段\n最后是set —- 这个 set 的用法，不同于入口处的 set ，这里的含义很有趣：\n官方文档中是这样描述的：\nBash Reference Manual - 4.3.1 The Set Builtin\n-- :\nIf no arguments follow this option, then the positional parameters are unset. Otherwise, the positional parameters are set to the arguments, even if some of them begin with a ‘-’.\nset -- 如果后续没有 set -- 参数,则会将全部的参数清空，否则会依次赋值给位置参数 ${1}、${2}...,即使有些参数以 - 开头。\n- :\nSignal the end of options, cause all remaining arguments to be assigned to the positional parameters. The -x and -v options are turned off. If there are no arguments, the positional parameters remain unchanged.\nset - 如果后续没有 set - 参数，不改变本身传递的参数，但如果设置了参数，同样会依次赋值给位置参数 ${1}、${2}... ，不过在使用后使用set -xv不会在打印输出脚本的调试信息，意味着确认输入参数的阶段已经结束\n#!/bin/bash set -- php-fpm \"$@\" # 用于将 php-fpm 设置在 option 其中的前方 set -- \"$@\" php # 在所有参数后插入 php set -- \"-ini\" \"$@\" # 在所有的参数前放置 -ini set -- \"$1\" ok # 在第一个位后方放置ok ，但是截取后方全部 set -- \"$@\" ok # 在所有参数后放置ok 我们回到当前的脚本中，发现如果输入的参数是 - 开头的话，那么 $@ 就变为了 php-fpm + $@ 然后 通过exec “$@” 被执行。假如输入的是一个其他的完整的命令，或者可执行文件，则不会被替换掉，可以通过exec直接执行 $@。\n所以利用 Dockerfile 中 ENTRYPOINT 和 CMD 的特性，默认镜像会在容器启动的时，启动 php-fpm 服务，但我们也可以替换 CMD 传入 -v 来实现 替换原本的CMD[’php-fpm’], 来通过入口文件获取php的版本。\n","wordCount":"351","inLanguage":"zh","datePublished":"2022-08-29T12:14:34+08:00","dateModified":"2022-08-29T12:14:34+08:00","author":{"@type":"Person","name":"易初"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://y7ut.github.io/zh/blog/zh/learn-design-image-entrypoint/"},"publisher":{"@type":"Organization","name":"还是偶尔想要伟大","logo":{"@type":"ImageObject","url":"https://y7ut.github.io/favicon.ico"}}}</script><link rel=icon type=image/png href=/images/robot.ico sizes=16x16><link rel=apple-touch-icon href=/images/robot.ico><link rel=manifest href=/images/robot.ico><link rel=stylesheet href=/css/main.min.64bc8c4cb2304e84167c1583fa1b5de80f6d5adc95abed2e616dea0ea5680e01.css integrity="sha256-ZLyMTLIwToQWfBWD+htd6A9tWtyVq+0uYW3qDqVoDgE=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.698bc9ccb8ccaf7f58dc58847b72072cc4b88774110168045d5299bbaee4b1ca.js></script>
<script>hljs.highlightAll()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/zh>HOME</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/zh/blog>文章</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/zh/tags>分类</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/zh/archives>历史文章</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/y7ut><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li><li class="navigation-item navigation-language"><a href=https://y7ut.github.io/>EN</a></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>如何设计容器的 Entrypoint 🚪</h1></header><p><small>2022年8月29日&nbsp;· 351 字&nbsp;· 2 分钟</small>
<small>·
<a href=https://y7ut.github.io/zh/tags/bash/>bash</a>
<a href=https://y7ut.github.io/zh/tags/docker/>docker</a></small><p><div class=blog-toc><nav id=TableOfContents><ul><li><ul><li><a href=#bash脚本中的set指令>bash脚本中的set指令</a></li><li><a href=#修改脚本的输入参数>修改脚本的输入参数</a></li></ul></li></ul></nav></div><section class=blog-content><p>在整理<code>php-fpm</code>官方镜像构架方法的时候，注意到了一个入口文件 <code>docker-php-entrypoint</code>， 和 DockerFile 的写法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=display:flex><span><span style=color:#66d9ef>ENTRYPOINT</span> [<span style=color:#e6db74>&#34;docker-php-entrypoint&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>CMD</span> [<span style=color:#e6db74>&#34;php-fpm&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>为什么要要这样设计呢，入口文件的好处是什么的呢？</p><p>🤔️我们来研究一下，先看一下这个 <code>docker-php-entrypoint</code> 文件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/sh
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>set -e
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># first arg is `-f` or `--some-option`</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>1#-<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> !<span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;</span>$1<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span> set -- php-fpm <span style=color:#e6db74>&#34;</span>$@<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>exec <span style=color:#e6db74>&#34;</span>$@<span style=color:#e6db74>&#34;</span>
</span></span></code></pre></div><h3 id=bash脚本中的set指令>bash脚本中的set指令</h3><p>从上到下看，先看一下文件开头的set -e</p><p>最常用的两个参数就是 <code>-e</code> 与 <code>-x</code> ，一般写在 <code>bash</code> 脚本的代码逻辑之前，这两个组合在一起用，可以在 Debug 的时候替你节省许多时间 。</p><ul><li><code>set -x</code> 会在执行每一行 <code>shell</code>时，把执行的内容输出来。它可以让你看到当前执行的情况，里面涉及的变量也会被替换成实际的值。</li><li><code>set -v</code> 会在执行每一行 <code>shell</code>时，把执行的内容输出来, 但里面涉及的变量不会被替换。</li><li><code>set -e</code> 会在执行出错时结束程序，就像其他语言中的“抛出异常”一样。</li><li><code>set -u</code> 会在执行 <code>shell</code>时, 如果遇到不存在的变量会忽略掉这个问题</li></ul><p>例如</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e># 打印每一行语句的执行情况，执行错误时，则立即退出脚本</span>
</span></span><span style=display:flex><span><span style=color:#75715e># set [-可选参数] [-o 选项]</span>
</span></span><span style=display:flex><span>set -ex
</span></span></code></pre></div><p>当然还有一些参数需要携带option， 也是常用的设置，例如:</p><ul><li><code>set -o pipefail</code> 对于用管道符<code>|</code>连接的命令，如果最后一个命令执行成功，那么这整个命令则会被认为执行成功，大多数情况下是不符合我们需求的。所以设置了这个选项之后，某个子命令出错的时候直接退出。</li></ul><p>所以我们在设计一些脚本的时候，可以调加这样的配置让脚本更健壮。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>set -euxo pipefail
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><h3 id=修改脚本的输入参数>修改脚本的输入参数</h3><p>一般来说，在shell脚本中 <code>$1,$2,$3,$@</code> , 用来代表输入的参数</p><ul><li><code>$!</code> ：Shell最后运行的后台 Process 的 PID (后台运行的最后一个进程的进程 ID 号)。</li><li><code>$#</code> ：添加到shell当中参数的个数.</li><li><code>$$</code> ：Shell 本身的 PID (ProcessID，即脚本运行的当前进程 ID 号)。</li><li><code>$0</code> ：脚本本身的文件名.</li><li><code>$1</code> ：传到 Shell 当中的第一个参数。</li><li><code>$2</code> ：传到 Shell 当中的第二个参数。</li><li><code>$*</code> ：所有参数列表。如 <code>$*</code> 用" &ldquo;括起来的情况、以 <code>$1 $2 … $n</code> 的形式输出所有参数，此选项参数可超过9个；若不加&rdquo; &ldquo;，那么 <code>$*</code> 与 <code>$@</code> 的输出结果相同</li><li><code>$@</code> ：所有参数列表。如 <code>$@</code> 用&rdquo; &ldquo;括起来的情况、以 <code>$1</code> 、<code>$2</code>、 … <code>$n</code> 的形式输出所有参数。</li></ul><p>所以php-fpm-entrypoint的这个 <code>${1#-}</code> 其实则是指的是用来，获取第一个参数，并去除掉左面的第一个 <code>-</code>。</p><div class="tabs tabs-left"><style>.tabs input#tab-0-0:checked~.tab-content-0-0{display:block}</style><input type=radio class=tab-input name=tab-select-0 id=tab-0-0 checked>
<label for=tab-0-0 class=tab-label>eg.1</label><div class="tab-content tab-content-0-0"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#e6db74>${</span>1#*-<span style=color:#e6db74>}</span> <span style=color:#75715e># 去除掉左面第一个-和左面所有字符</span>
</span></span></code></pre></div></div><style>.tabs input#tab-0-1:checked~.tab-content-0-1{display:block}</style><input type=radio class=tab-input name=tab-select-0 id=tab-0-1>
<label for=tab-0-1 class=tab-label>eg.2</label><div class="tab-content tab-content-0-1"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#e6db74>${</span>1#-*<span style=color:#e6db74>}</span> <span style=color:#75715e># 去除掉左面第一个-和右面所有字符</span>
</span></span></code></pre></div></div><style>.tabs input#tab-0-2:checked~.tab-content-0-2{display:block}</style><input type=radio class=tab-input name=tab-select-0 id=tab-0-2>
<label for=tab-0-2 class=tab-label>eg.3</label><div class="tab-content tab-content-0-2"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#e6db74>${</span>1##-*<span style=color:#e6db74>}</span> <span style=color:#75715e># 去除掉左面数最后一个（右面第一个）- 和右面所有字符</span>
</span></span></code></pre></div></div><style>.tabs input#tab-0-3:checked~.tab-content-0-3{display:block}</style><input type=radio class=tab-input name=tab-select-0 id=tab-0-3>
<label for=tab-0-3 class=tab-label>eg.4</label><div class="tab-content tab-content-0-3"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#e6db74>${</span>1%-*<span style=color:#e6db74>}</span> <span style=color:#75715e># 去除掉右面第一个- 和右面所有字符</span>
</span></span></code></pre></div></div><style>.tabs input#tab-0-4:checked~.tab-content-0-4{display:block}</style><input type=radio class=tab-input name=tab-select-0 id=tab-0-4>
<label for=tab-0-4 class=tab-label>eg.5</label><div class="tab-content tab-content-0-4"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#e6db74>${</span>1%%*-<span style=color:#e6db74>}</span> <span style=color:#75715e># 去除掉右面数最后一个一个（左面第一个）- 和左面所有字符</span>
</span></span></code></pre></div></div></div><p>所以 <code>${1#-}</code> 表达的，如果输入的第一个参数不是去掉了左侧第一个的<code>-</code>不等于参数本身</p><p>可以理解为 如果输入的是一个 <code>-v</code> 或者 <code>—int</code> 类似参数的话，就会进入if的代码段</p><p>最后是<code>set —-</code> 这个 <code>set</code> 的用法，不同于入口处的 <code>set</code> ，这里的含义很有趣：</p><p>官方文档中是这样描述的：</p><p><a href=https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html>Bash Reference Manual - 4.3.1 The Set Builtin</a></p><blockquote><p><code>--</code> :</p><p>If no arguments follow this option, then the positional parameters are unset. Otherwise, the positional parameters are set to the arguments, even if some of them begin with a &lsquo;-&rsquo;.</p></blockquote><p><code>set --</code> 如果后续没有 <code>set --</code> 参数,则会将全部的参数清空，否则会依次赋值给位置参数 <code>${1}、${2}...</code>,即使有些参数以 <code>-</code> 开头。</p><blockquote><p><code>-</code> :</p><p>Signal the end of options, cause all remaining arguments to be assigned to the positional parameters. The -x and -v options are turned off. If there are no arguments, the positional parameters remain unchanged.</p></blockquote><p><code>set -</code> 如果后续没有 <code>set -</code> 参数，<strong>不改变</strong>本身传递的参数，但如果设置了参数，同样会依次赋值给位置参数 <code>${1}、${2}...</code> ，不过在使用后使用<code>set -xv</code>不会在打印输出脚本的调试信息，意味着确认输入参数的阶段已经结束</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>set -- php-fpm <span style=color:#e6db74>&#34;</span>$@<span style=color:#e6db74>&#34;</span> 
</span></span><span style=display:flex><span><span style=color:#75715e># 用于将 php-fpm 设置在 option 其中的前方</span>
</span></span><span style=display:flex><span>set --  <span style=color:#e6db74>&#34;</span>$@<span style=color:#e6db74>&#34;</span> php  <span style=color:#75715e># 在所有参数后插入 php</span>
</span></span><span style=display:flex><span>set -- <span style=color:#e6db74>&#34;-ini&#34;</span> <span style=color:#e6db74>&#34;</span>$@<span style=color:#e6db74>&#34;</span>  <span style=color:#75715e># 在所有的参数前放置 -ini</span>
</span></span><span style=display:flex><span>set --  <span style=color:#e6db74>&#34;</span>$1<span style=color:#e6db74>&#34;</span> ok  <span style=color:#75715e># 在第一个位后方放置ok ，但是截取后方全部</span>
</span></span><span style=display:flex><span>set --  <span style=color:#e6db74>&#34;</span>$@<span style=color:#e6db74>&#34;</span> ok  <span style=color:#75715e># 在所有参数后放置ok</span>
</span></span></code></pre></div><p>我们回到当前的脚本中，发现如果输入的参数是 <code>-</code> 开头的话，那么 <code>$@</code> 就变为了 <code>php-fpm</code> + <code>$@</code> 然后 通过<code>exec “$@”</code> 被执行。假如输入的是一个其他的完整的命令，或者可执行文件，则不会被替换掉，可以通过exec直接执行 <code>$@</code>。</p><p>所以利用 <code>Dockerfile</code> 中 <code>ENTRYPOINT</code> 和 <code>CMD</code> 的特性，默认镜像会在容器启动的时，启动 <code>php-fpm</code> 服务，但我们也可以替换 <code>CMD</code> 传入 <code>-v</code> 来实现 替换原本的<code>CMD[’php-fpm’],</code> 来通过入口文件获取php的版本。</p></section></article></div><footer class=footer><p>&copy; 2022 <a href=https://y7ut.github.io>还是偶尔想要伟大</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-up"><line x1="12" y1="19" x2="12" y2="5"/><polyline points="5 12 12 5 19 12"/></svg></a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>